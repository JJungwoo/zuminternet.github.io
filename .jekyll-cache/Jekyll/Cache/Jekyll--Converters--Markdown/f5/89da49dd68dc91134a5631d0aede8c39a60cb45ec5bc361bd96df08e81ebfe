I"(G<blockquote>
  <p>개별 서비스에 직접적인 영향은 없으나 서비스 유지보수에 도움이 되는 Quartz Scheduler Admin 에 대한 고도화 작업을 진행함으로서
  실무 투입전 포털개발팀에서 사용하는 기술 스펙 적응 및 업무 프로세스 등을 익히고
  파일럿 프로젝트 이후에도 계속 사용할 수 있는 산출물을 남김으로서 팀에 기여 하고자 하였습니다.</p>
</blockquote>

<h2 id="intro">Intro</h2>

<h3 id="quartz-scheduler-admin-이란">Quartz Scheduler Admin 이란?</h3>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/02-quartz_job_scheduler.PNG" alt="02-quart_job_scheduler" /></p>

<p>Quartz Job Scheduler 는 DB 기반으로 스케줄러 간의 클러스터링 기능을 제공합니다. 
<img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/01-what_is_quartz_scheduler_admin.svg" alt="01-what_is_quartz_scheduler_admin" />
Quartz Scheduler Admin 은 Quartz Job Scheduler 의 DB 관리를 위한 Admin 입니다.</p>

<h3 id="배경">배경</h3>
<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/03-quartz_admin_scheduler_before_after.svg" alt="03-quartz_admin_scheduler_before_after" /></p>

<h4 id="기존에는"><strong>기존에는</strong></h4>
<p>Common Scheduler DB 안에 모든 서비스의 Job Scheduler 를 담고 있었으며,<br />
Common Scheduler DB 에 대한 Quartz Scheduler Admin 이 존재하였습니다.</p>

<h4 id="하지만-db-의-장애가-발생하였을-때">하지만 DB 의 장애가 발생하였을 때</h4>
<p>모든 서비스의 Batch 가 중단되는 문제가 있었습니다.  <br />
이를 해결하기 위해 각 서비스 별 Scheduler DB 로 분산하게 되었고, 
Quartz Scheduler Admin 은 더 이상 사용을 할 수 없게 되었습니다.</p>

<h3 id="목표">목표</h3>
<p>Common Scheduler DB 를 각 서비스 별 Scheduler DB 로 분산하게 되면서 사용이 중단된 Quartz Scheduler Admin 을 
다시 사용할 수 있도록 프로젝트 구조를 변경하고 어플리케이션의 효용성을 높이기 위한 고도화를 진행하였습니다.</p>

<h2 id="프로젝트-결과물">프로젝트 결과물</h2>

<h3 id="1-서비스-별-scheduler-db-관리-기능-추가">1. 서비스 별 Scheduler DB 관리 기능 추가</h3>
<h4 id="before">BEFORE</h4>
<p>Common Scheduler DB 에 대해서만 Quartz Scheduler Admin 을 사용할 수 있었습니다.</p>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/04-quartz-admin_before.png" alt="04-quartz-admin_before" /></p>

<h4 id="after">AFTER</h4>
<p><strong>[Management &gt; DB Config]</strong> 메뉴에서, 서비스 별 Scheduler DB 를 동적으로 관리할 수 있게 되었습니다.</p>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/05-dbconfig_main.jpg" alt="05-dbconfig_main" /></p>

<p>추가된 서비스는 사이드바 메뉴에 생성이 됩니다.     <br />
<code class="language-plaintext highlighter-rouge">Connection</code> 이 유효하지 않는 DB 는 사이드바 메뉴에 나타나지 않습니다.</p>

<p><img style="width:50%" src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/06-dbcofig_sidebar.png" /></p>

<p>서비스가 늘어남에 따라 메뉴가 복잡해 질 것을 고려해, 서비스 별 메뉴와 같이 UI 를 개편이 필요할 것 같습니다.</p>

<ol>
  <li>우측 상단의 <strong>Add</strong> 버튼을 누르면 DB 를 추가할 수 있습니다.
<img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/07-dbconfig_add.png" alt="!07-dbconfig_add" /></li>
  <li><code class="language-plaintext highlighter-rouge">ServiceKey</code>
    <ul>
      <li>ServiceKey 는 ASCII 문자만 입력가능합니다.  그 이유는, ServiceKey 가 유니코드외 문자라면 <code class="language-plaintext highlighter-rouge">path variables</code> 에 포함이 될 때 인코딩되는 문제가 발생하기 때문입니다.</li>
      <li>스프링 서버로 Http Request 요청 시 Header 에 포함됩니다. 스프링 서버는 Headers 의 <code class="language-plaintext highlighter-rouge">service-key</code> 의 값으로 DataSource 를 결정하게 됩니다.</li>
      <li>예시) news</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">DBConnectionName</code>
    <ul>
      <li>좌측 사이드바 메뉴에서 나타낼 DB 의 이름 입니다.</li>
      <li>예시) 뉴스</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">DriverClassName</code>
    <ul>
      <li>스프링 서버에서 사용할 JDBC 드라이버의 종류 입니다.</li>
      <li>현재 버전에서는 <code class="language-plaintext highlighter-rouge">com.mysql.cj.jdbc.Driver</code> 만 사용 가능합니다.</li>
      <li>기본 값은 <code class="language-plaintext highlighter-rouge">com.mysql.cj.jdbc.Driver</code> 입니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">URL</code>
    <ul>
      <li>DB 의 URL 입니다.</li>
      <li>예시) jdbc:mysql://127.0.0.1:3306/database_name?serverTimezone=Asia/Seoul&amp;characterEncoding=UTF-8</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">UserName</code>
    <ul>
      <li>Database 의 username 입니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Password</code>
    <ul>
      <li>Database 의 password 입니다.</li>
      <li>기본값은 빈 문자열 <code class="language-plaintext highlighter-rouge">''</code> 입니다.</li>
    </ul>
  </li>
  <li>폼을 모두 입력한 후 <code class="language-plaintext highlighter-rouge">Test Connection</code> 버튼을 누르면 해당 DB 접속 정보가 유효하여 연결이 가능한지 테스트 할 수 있습니다. 만약 테스트에 성공하면 성공 메세지와 함께 버튼의 색깔이 녹색으로 변합니다.</li>
</ol>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/08-dbconfig_detail.jpg" alt="08-dbconfig_detail" /></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Detail</code> 버튼을 눌러 자세한 DB 정보를 조회할 수 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">Modify</code> 버튼을 눌러 DB Connection Detail 을 수정할 수 있습니다.
<img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/09-dbconfig_modify.jpg" alt="09-dbconfig_modify" /></li>
</ol>

<h3 id="2-job-실행-기능-개선">2. Job 실행 기능 개선</h3>

<h4 id="before-1">BEFORE</h4>
<p>해당 Job 을 즉시 실행하기 위해서는, Trigger 의 <code class="language-plaintext highlighter-rouge">StartTime</code> 을 현재시간보다 이전으로 설정하고,
<code class="language-plaintext highlighter-rouge">EndTime</code> 을 현재시간 이후로 설정을 해주면 됩니다.</p>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/10-add_simple_trigger.gif" alt="10-add_simple_trigger" /></p>

<p>기존에는, 즉시 실행을 하기 위해서 SimpleTrigger 폼을 직접 입력해 주어야 했습니다.</p>

<h4 id="after-1">AFTER</h4>
<p><code class="language-plaintext highlighter-rouge">Execution</code> 버튼 하나만으로 Job 을 즉시실행 할 수 있습니다.</p>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/11-add_simple_trigger_after.gif" alt="11-add_simple_trigger_after" /></p>

<p><code class="language-plaintext highlighter-rouge">TriggerGroup</code> 과 <code class="language-plaintext highlighter-rouge">TriggerName</code> 은 다음과 같은 양식으로 랜덤으로 생성 됩니다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">TriggerGroup</code> : INTERNAL-<code class="language-plaintext highlighter-rouge">JobGroup</code>-triggerGroup-<code class="language-plaintext highlighter-rouge">UUIDv4</code></li>
  <li><code class="language-plaintext highlighter-rouge">TriggerName</code> : INTERNAL-<code class="language-plaintext highlighter-rouge">JobName</code>-triggerName-<code class="language-plaintext highlighter-rouge">UUIDv4</code></li>
</ul>

<h3 id="3-구글-oauth-로그인-기능-추가">3. 구글 oAuth 로그인 기능 추가</h3>
<p>구글 로그인 기능이 추가 되었습니다.</p>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/12-login.gif" alt="12-login" /></p>

<p>로그인 가능한 이메일 도메인을 제한하였으며 이외의 도메인으로 로그인을 시도한다면 로그인에러 페이지로 리디렉션 됩니다.
이 때, 다른 계정으로 로그인을 시도하려면 구글 계정을 완전히 로그아웃 시켜야 합니다.</p>

<p>해당 링크로 접속하면, 현재 브라우저에 로그인 되어있는 구글 아이디를 로그아웃 할 수 있습니다. <br />
<code class="language-plaintext highlighter-rouge">https://www.google.com/accounts/Logout?continue=https://appengine.google.com/_ah/logout</code></p>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/13-login_fail.gif" alt="13-login_fail" /></p>

<p>우측 상단에 <code class="language-plaintext highlighter-rouge">logout</code> 혹은 <code class="language-plaintext highlighter-rouge">login</code> 버튼이 존재합니다. <br />
logout 버튼 왼쪽의 <code class="language-plaintext highlighter-rouge">refresh</code> 아이콘 버튼을 눌러 로그인을 재시도 하여 세션을 <code class="language-plaintext highlighter-rouge">refresh</code> 할 수 있습니다.  <br />
마지막 Http Request 후 30 분이 지나거나, 유저의 권한이 변경될 때 세션이 만료됩니다.</p>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/14-logout_refresh.gif" alt="14-logout_refresh" /></p>

<h4 id="로그인-히스토리">로그인 히스토리</h4>
<p>로그인 한 사용자의 기록은 <strong>[Management &gt; Login History]</strong> 메뉴에서 확인 할 수 있습니다. <br />
로그인 시간, IP, 접속한 사용자의 이름과 이메일이 기록됩니다.</p>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/16-user_login_history.png" alt="16-user_login_history" /></p>

<h4 id="사용자의-권한">사용자의 권한</h4>
<p>사용자의 권한에는 3가지가 존재합니다.
권한 별로 접근 가능한 메뉴와 API 가 달라집니다.
아래 리스트의 하위로 갈 수록 권한이 확장 됩니다.</p>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/15-user_auth.PNG" alt="15-user_auth" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">BLOCK</code>
    <ul>
      <li>Info</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">USER</code>
    <ul>
      <li>DashBoard</li>
      <li>Quartz Job</li>
      <li>CronTrigger</li>
      <li>SimpleTrigger</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ADMIN</code>
    <ul>
      <li>Management</li>
    </ul>
  </li>
</ul>

<h4 id="사용자의-권한을-변경">사용자의 권한을 변경</h4>
<p>최초 로그인을 하였을 때, 사용자의 권한 레벨은 <code class="language-plaintext highlighter-rouge">BLOCK</code> 이기 때문에 <code class="language-plaintext highlighter-rouge">ADMIN</code> 의 승인이 필요합니다.</p>

<p><strong>[Management &gt; User]</strong> 메뉴에서 사용자의 권한을 변경할 수 있습니다.  <br />
이때, 해당 사용자의 권한이 변경되면 세션이 만료되므로 해당 사용자는 <code class="language-plaintext highlighter-rouge">logout</code> 버튼 왼쪽의 <code class="language-plaintext highlighter-rouge">refresh</code> 버튼을 클릭하여 세션을 다시 갱신해야 합니다.</p>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/17-user_auth_change.gif" alt="17-user_auth_change" /></p>

<h3 id="4-각-서비스-admin-에서-연동하여-사용할-수-있는-api-개발">4. 각 서비스 Admin 에서 연동하여 사용할 수 있는 API 개발</h3>
<p>서비스 별 어드민 서버에서, Quartz Scheduler Admin API 를 호출하여 해당 Job 실행 할 수 있습니다.</p>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/18-scheduler_admin_api.svg" alt="18-scheduler_admin_api" /></p>

<h3 id="5-job-실행-이력관리-기능">5. job 실행 이력관리 기능</h3>
<p><strong>[Management &gt; Job History]</strong> 메뉴에서 Job 의 Simple Trigger 생성 히스토리를 조회할 수 있습니다. 
<img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/18-job_history.gif" alt="18-job_history" /></p>

<p>Simple Trigger 는 두가지 방법으로 추가할 수 있습니다. <code class="language-plaintext highlighter-rouge">Method</code> 컬럼의 값은 두가지가 있습니다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">INTERNAL</code> : Quartz Scheduler Admin 내 에서 추가되었을 경우</li>
  <li><code class="language-plaintext highlighter-rouge">EXTERNAL</code> : 각 서비스 CSM 서버의 요청으로 추가된 경우</li>
</ul>

<h2 id="프로젝트-설계">프로젝트 설계</h2>

<h3 id="기술-스택">기술 스택</h3>
<h4 id="back-end">Back end</h4>
<ul>
  <li>Spring Boot v2.1.6</li>
  <li>Gradle v5.4.1</li>
  <li>Java 8</li>
  <li>JPA</li>
</ul>

<h4 id="front-end">Front end</h4>
<ul>
  <li>Webpack</li>
  <li>Vue Cli 3</li>
  <li>ES 2020</li>
  <li>Element-UI</li>
</ul>

<h3 id="1-simple-service-structure">1. Simple Service Structure</h3>
<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/19-service_architecture.svg" alt="19-service_architecture" /></p>

<h3 id="2-client">2. Client</h3>
<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/20-client_architecture.svg" alt="20-client_architecture" /></p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>frontend
├─public
│      index.html   
└─src
   │  App.vue
   │  main.js
   ├─adapters                       <span class="c"># http request 모듈 </span>
   ├─commons                        <span class="c"># 공용 모듈    </span>
   ├─config                     
   │      AxiosIntercepter.js      
   ├─layout                     
   ├─router         
   ├─store
   └─views
   └─components
     └─base                         <span class="c"># 공용 컴포넌트</span>
</code></pre></div></div>

<h3 id="3-server">3. Server</h3>
<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/21-spring_server_architecture.svg" alt="21-spring_server_architecture" /></p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└─com.quartz.admin
    │  QuartzVueAdminApplication.java
    ├─annotations
    ├─config
    │  │  WebMvcConfig.java
    │  ├─auth                 <span class="c"># spring security 와 google oauth2 설정</span>
    │  └─dataSource           <span class="c"># RoutingDataSource 설정</span>
    ├─controller
    │  ├─api
    │  ├─path
    │  └─view
    │  HomeViewController.java
    ├─property
    ├─domain
    └─util
</code></pre></div></div>

<h3 id="4-database">4. DataBase</h3>
<p>Spring Data JPA <code class="language-plaintext highlighter-rouge">Entity</code> 를 이용하여 테이블을 정의하였습니다. 
<img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/22-database.PNG" alt="22-database" /></p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">INFO_OF_DB_CONNECTIONS</code>
    <ul>
      <li>각 서비스의 Database Connection 정보를 담고 있습니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">TRIGGER_HISTORIES</code>
    <ul>
      <li>JOB 의 SIMPLE TRIGGER 생성 정보를 기록합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">JOB_HISTORIES</code>
    <ul>
      <li>TRIGGER_HISTORIES 의 생성 정보를 기록합니다.</li>
      <li>외래키로 조인된 PRIMARY KEY 입니다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">TRIGGER_HISTORY_ID</code> UNIQUE KEY</li>
          <li><code class="language-plaintext highlighter-rouge">INFO_OF_DB_CONNECTION_ID</code> 트리거 가 추가된 서비스 데이터베이스 정보</li>
        </ul>
      </li>
      <li>트리거가 생성될 때 생성시간, 생성자의 이메일, 아이피주소, 성명 을 수집합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">USERS</code>
    <ul>
      <li>Google OAuth 로 가입한 사용자의 이름, 이메일 주소, 권한 정보를 수집합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">LOGIN_HISTORIES</code>
    <ul>
      <li>Google OAuth 로 로그인을 할 때마다, 로그인한 사용자의 정보를 기록합니다.</li>
      <li>사용자의 이메일, 아이피 주소, 로그인시간, 성명 을 수집합니다.</li>
    </ul>
  </li>
</ol>

<h2 id="dynamic-multi-datasourcing">Dynamic Multi DataSourcing</h2>
<p>여러 DataSource 들을 런타임으로 추가, 삭제, 변경 하는 방법에 대해 소개 합니다.</p>

<p>기능을 구현하기 위해 <code class="language-plaintext highlighter-rouge">AbstractRoutingDataSource</code> 를 상속한 <code class="language-plaintext highlighter-rouge">RoutingDataSource</code> 를 구현하였습니다. 
그 이유는 AbstractRoutingDataSource 특징인 다음과 같습니다.</p>

<ol>
  <li>동일 DB 스키마에 대한 다중 DB 접속 처리 가능합니다.
기존의 Common Scheduler DB 가 분산된 것이므로 각 서비스 별, 스키마, API 로직이 모두 동일합니다.</li>
  <li>DataSource 는 <code class="language-plaintext highlighter-rouge">DataSourceLookupKeyContextHolder</code> 를 기반으로 런타임에 동적으로 결정될 수 있습니다.</li>
  <li>IsolationLevelDataSourceRouter 트랜잭션 별 격리 수준을 보장합니다.</li>
</ol>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/30-extends_abstract_rounting_ds.svg" alt="30-extends_abstract_rounting_ds" /></p>

<h3 id="1-abstractroutingdatasource">(1) AbstractRoutingDataSource</h3>
<p>구현을 하기 전, AbstractRoutingDataSource 에 대해서 소개하겠습니다.    <br />
주요 멤버변수와 메서드는 다음과 같습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractRoutingDataSource</span> <span class="kd">extends</span> <span class="nc">AbstractDataSource</span> <span class="kd">implements</span> <span class="nc">InitializingBean</span> <span class="o">{</span>

	<span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">targetDataSources</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">Object</span> <span class="n">defaultTargetDataSource</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">DataSource</span><span class="o">&gt;</span> <span class="n">resolvedDataSources</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">DataSource</span> <span class="n">resolvedDefaultDataSource</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTargetDataSources</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">targetDataSources</span><span class="o">);</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDefaultTargetDataSource</span><span class="o">(</span><span class="nc">Object</span> <span class="n">defaultTargetDataSource</span><span class="o">);</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterPropertiesSet</span><span class="o">();</span> 
	<span class="kd">public</span> <span class="nc">Connection</span> <span class="nf">getConnection</span><span class="o">();</span>

	<span class="kd">protected</span> <span class="nc">DataSource</span> <span class="nf">determineTargetDataSource</span><span class="o">();</span>
	<span class="kd">protected</span> <span class="kd">abstract</span> <span class="nc">Object</span> <span class="nf">determineCurrentLookupKey</span><span class="o">();</span>

<span class="o">}</span>
</code></pre></div></div>

<h4 id="private-mapobject-object-targetdatasources">private Map&lt;Object, Object&gt; targetDataSources</h4>
<ul>
  <li>각 서비스의 Datasource 정보들이 Map 으로 저장됩니다.</li>
  <li>public void setTargetDataSources(Map&lt;Object, Object&gt; targetDataSources) 메서드로 값을 변경할 수 있습니다.</li>
</ul>

<h4 id="private-object-defaulttargetdatasource">private Object defaultTargetDataSource</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">lookupKey</code> 에 해당하는 DataSource 를 찾지 못했을 때 사용되는, 기본 DataSource 입니다.</li>
  <li>public void setDefaultTargetDataSource(Object defaultTargetDataSource) 메서드로 값을 변경할 수 있습니다.</li>
</ul>

<h4 id="private-mapobject-datasource-resolveddatasources-private-datasource-resolveddefaultdatasource">private Map&lt;Object, DataSource&gt; resolvedDataSources; private DataSource resolvedDefaultDataSource</h4>
<ul>
  <li>DataSource 를 결정할 때에는 targetDataSources/defaultTargetDataSource 가 아닌 <code class="language-plaintext highlighter-rouge">resolvedDataSources</code>/<code class="language-plaintext highlighter-rouge">resolvedDefaultDataSource</code> 에서 참조합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">public void afterPropertiesSet()</code> 메서드에서 targetDataSources/defaultTargetDataSource 의 값을 resolvedDataSources/resolvedDefaultDataSource 으로 복사합니다.</li>
</ul>

<h4 id="database-와의-connection-을-생성합니다">Database 와의 connection 을 생성합니다.</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Connection</span> <span class="nf">getConnection</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">SQLException</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">determineTargetDataSource</span><span class="o">().</span><span class="na">getConnection</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="protected-datasource-determinetargetdatasource">protected DataSource determineTargetDataSource()</h4>
<p>connection 을 설정할 Datasource 를 결정합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="nc">DataSource</span> <span class="nf">determineTargetDataSource</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">resolvedDataSources</span><span class="o">,</span> <span class="s">"DataSource router not initialized"</span><span class="o">);</span>
    <span class="nc">Object</span> <span class="n">lookupKey</span> <span class="o">=</span> <span class="n">determineCurrentLookupKey</span><span class="o">();</span> <span class="c1">// lookupKey 의 값을 가져옵니다</span>
    <span class="nc">DataSource</span> <span class="n">dataSource</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">resolvedDataSources</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">lookupKey</span><span class="o">);</span>

    <span class="c1">// resolvedDataSources 에서 lookupKey 로 값을 가져 올 수 없다면 resolvedDefaultDataSource 를 사용합니다.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">dataSource</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">lenientFallback</span> <span class="o">||</span> <span class="n">lookupKey</span> <span class="o">==</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">dataSource</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">resolvedDefaultDataSource</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">dataSource</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"Cannot determine target DataSource for lookup key ["</span> <span class="o">+</span> <span class="n">lookupKey</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">dataSource</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2-routingdatasource">(2) RoutingDataSource</h3>
<p>RoutingDataSource 는 AbstractRoutingDataSource 을 확장한 클래스 입니다.</p>

<p>확장한 AbstractRoutingDataSource 를 조작하기 위한 인터페이스를 갖는 것이 특징입니다.</p>

<p>여기서 눈 여겨 봐야 할 것은 오버라이드 한 <code class="language-plaintext highlighter-rouge">determineCurrentLookupKey()</code> 메서드 입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="nc">String</span> <span class="nf">determineCurrentLookupKey</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">DataSourceLookupKeyContextHolder</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>DataSourceLookupKeyContextHolder 클래스의 <code class="language-plaintext highlighter-rouge">ThreadLocal</code> 타입인 <code class="language-plaintext highlighter-rouge">DATA_SOURCE_KEY</code> 를 참조하고 있습니다.
만약 <code class="language-plaintext highlighter-rouge">DATA_SOURCE_KEY</code> 의 값이 <code class="language-plaintext highlighter-rouge">news</code> 라면 <code class="language-plaintext highlighter-rouge">resolvedDataSources</code> 의 해시 값 중, 키가 <code class="language-plaintext highlighter-rouge">news</code> 인 Datasource 가 결정이 될 것 입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DataSourceLookupKeyContextHolder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="no">DATA_SOURCE_KEY</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">String</span> <span class="n">dataSourceType</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">DataSourceLookupKeyContextHolder</span><span class="o">.</span><span class="na">DATA_SOURCE_KEY</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">dataSourceType</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">DATA_SOURCE_KEY</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">DataSourceLookupKeyContextHolder</span><span class="o">.</span><span class="na">DATA_SOURCE_KEY</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://javacan.tistory.com/entry/ThreadLocalUsage">ThreadLocal</a> 를 이용하면 쓰레드 영역에 변수를 설정할 수 있기 때문에, 
특정 쓰레드가 실행하는 모든 코드에서 그 쓰레드에 설정된 변수 값을 사용할 수 있게 되는 특징을 가지고 있습니다.</p>
</blockquote>

<h3 id="3-admin-database-를-datasource-bean-을-생성">(3) Admin Database 를 Datasource Bean 을 생성</h3>
<p>제일 먼저 Admin Database 의 Datasource Bean 을 생성해야 합니다.    <br />
Admin Database 의 INFO_OF_DB_CONNECTIONS 테이블에는 다른 서비스들의 Database 커넥션 정보가 저장되어 있기 때문입니다.</p>

<p><code class="language-plaintext highlighter-rouge">application.yml</code> 의 <code class="language-plaintext highlighter-rouge">spring.datasource</code> 를 <code class="language-plaintext highlighter-rouge">DefaultDBProperty.class</code> 프로퍼티로 생성해 주었습니다.
<img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/28-diagram1.svg" alt="28-diagram1" /></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
  <span class="na">datasource</span><span class="pi">:</span>
    <span class="na">service-key</span><span class="pi">:</span> <span class="s2">"</span><span class="s">admin"</span>
    <span class="na">db-connection-name</span><span class="pi">:</span> <span class="s">관리자</span>
    <span class="na">url</span><span class="pi">:</span> <span class="s">jdbc:mysql://...?serverTimezone=Asia/Seoul&amp;characterEncoding=UTF-8</span>
    <span class="na">driver-class-name</span><span class="pi">:</span> <span class="s">com.mysql.cj.jdbc.Driver</span>
    <span class="na">username</span><span class="pi">:</span> <span class="s">...</span>
    <span class="na">password</span><span class="pi">:</span> <span class="s">...</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">DefaultDBProperty</code> 클래스는 멤버변수를 <code class="language-plaintext highlighter-rouge">InfoOfDBConnections</code> 타입으로 변환할 수 있는 <code class="language-plaintext highlighter-rouge">toInfoOfDBConnections()</code> 메서드가 존재합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="nd">@NoArgsConstructor</span>
<span class="nd">@ConfigurationProperties</span><span class="o">(</span><span class="n">prefix</span><span class="o">=</span><span class="s">"spring.datasource"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultDBProperty</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">serviceKey</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">url</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">driverClassName</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nc">InfoOfDBConnections</span> <span class="nf">toInfoOfDBConnections</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">InfoOfDBConnections</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
                              <span class="o">.</span><span class="na">serviceKey</span><span class="o">(</span><span class="n">serviceKey</span><span class="o">)</span>
                              <span class="o">.</span><span class="na">url</span><span class="o">(</span><span class="n">url</span><span class="o">)</span>
                              <span class="o">.</span><span class="na">username</span><span class="o">(</span><span class="n">username</span><span class="o">)</span>
                              <span class="o">.</span><span class="na">password</span><span class="o">(</span><span class="n">password</span><span class="o">)</span>
                              <span class="o">.</span><span class="na">driverClassName</span><span class="o">(</span><span class="n">driverClassName</span><span class="o">)</span>
                              <span class="o">.</span><span class="na">build</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/31-default_ds.svg" alt="31-default_ds" /></p>

<p>InfoOfDBConnections 타입으로 변환되면, 
<code class="language-plaintext highlighter-rouge">DataSourceWrapper.of</code> 인스턴스 생성자 매개변수의 인자로 사용됩니다.</p>

<p><code class="language-plaintext highlighter-rouge">DataSourceWrapper</code> 클래스는 TargetDataSources 해시 값의 키(serviceKey)-값(HikariDataSource)의 멤버변수에 대응됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@AllArgsConstructor</span><span class="o">(</span><span class="n">access</span> <span class="o">=</span> <span class="nc">AccessLevel</span><span class="o">.</span><span class="na">PRIVATE</span><span class="o">)</span>
<span class="nd">@NoArgsConstructor</span><span class="o">(</span><span class="n">access</span> <span class="o">=</span> <span class="nc">AccessLevel</span><span class="o">.</span><span class="na">PRIVATE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DataSourceWrapper</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">serviceKey</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">HikariDataSource</span> <span class="n">dataSource</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">DataSourceWrapper</span> <span class="nf">of</span><span class="o">(</span><span class="nc">InfoOfDBConnections</span> <span class="n">infoOfDBConnections</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">DataSourceWrapper</span><span class="o">(</span><span class="n">infoOfDBConnections</span><span class="o">.</span><span class="na">getServiceKey</span><span class="o">(),</span> <span class="n">createDataSource</span><span class="o">(</span><span class="n">infoOfDBConnections</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">HikariDataSource</span> <span class="nf">createDataSource</span><span class="o">(</span>
        <span class="nc">InfoOfDBConnections</span> <span class="n">infoOfDBConnections</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">DataSourceBuilder</span><span class="o">.</span><span class="na">create</span><span class="o">()</span>
                                <span class="o">.</span><span class="na">url</span><span class="o">(</span><span class="n">infoOfDBConnections</span><span class="o">.</span><span class="na">getUrl</span><span class="o">())</span>
                                <span class="o">.</span><span class="na">username</span><span class="o">(</span><span class="n">infoOfDBConnections</span><span class="o">.</span><span class="na">getUsername</span><span class="o">())</span>
                                <span class="o">.</span><span class="na">password</span><span class="o">(</span><span class="n">infoOfDBConnections</span><span class="o">.</span><span class="na">getPassword</span><span class="o">())</span>
                                <span class="o">.</span><span class="na">driverClassName</span><span class="o">(</span><span class="n">infoOfDBConnections</span><span class="o">.</span><span class="na">getDriverClassName</span><span class="o">())</span>
                                <span class="o">.</span><span class="na">type</span><span class="o">(</span><span class="nc">HikariDataSource</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
                                <span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">DefaultDataSourceConfig</code> 클래스 에서는 <code class="language-plaintext highlighter-rouge">defaultDataSource</code> 라는 <code class="language-plaintext highlighter-rouge">DataSourceWrapper</code> 타입을 반환하는 Bean 을 생성합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequiredArgsConstructor</span>
<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultDataSourceConfig</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">DefaultDBProperty</span> <span class="n">dbProperty</span><span class="o">;</span>

  <span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="nc">DataSourceWrapper</span> <span class="nf">defaultDataSource</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">DataSourceWrapper</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">dbProperty</span><span class="o">.</span><span class="na">toInfoOfDBConnections</span><span class="o">());</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="4-routingdatasource-타입의-datasource-bean-을-등록">(4) RoutingDataSource 타입의 DataSource Bean 을 등록</h3>
<p><code class="language-plaintext highlighter-rouge">DataSourceConfig</code> 클래스에서는 <code class="language-plaintext highlighter-rouge">RoutingDataSource</code> 타입의 DataSource Bean 을 등록합니다.</p>

<p>스프링부트가 실행될 때 자동으로, .yml 의 spring.datasource 의 값을 싱글 DataSource 로 <code class="language-plaintext highlighter-rouge">authConfiguration</code> 합니다.
하지만, <code class="language-plaintext highlighter-rouge">AbstractRoutingDataSource</code> 를 사용하여 멀티 DataSource 으로 커스텀 해야 하므로
SpringBootApplication 의 <code class="language-plaintext highlighter-rouge">DataSourceAutoConfiguration.class</code>을 <code class="language-plaintext highlighter-rouge">exclude</code> 해줍니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootApplication</span><span class="o">(</span><span class="n">exclude</span> <span class="o">=</span> <span class="o">{</span> <span class="nc">DataSourceAutoConfiguration</span><span class="o">.</span><span class="na">class</span> <span class="o">})</span>
<span class="nd">@EnableConfigurationProperties</span><span class="o">({</span> <span class="nc">DefaultDBProperty</span><span class="o">.</span><span class="na">class</span> <span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">QuartzVueAdminApplication</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// ...</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>초기의, RoutingDataSource 는 Admin DataSource 만 ResolvedDefaultDataSource 로 가지고 있습니다.</p>

<p>Admin DataSource 에서 가져온 서비스 별 Database 커넥션 정보들은 Application 실행 후 초기화 할 것 입니다.
Bean 생성 단계에서 JPA Repository Bean 을 주입하려고 하면 순환 참조의 문제가 발생하기 때문입니다.</p>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/32-circular_ref.svg" alt="32-circular_ref" /></p>

<ol>
  <li>JPA Repository Bean 은 DataSource Bean 이 주입되어야 합니다</li>
  <li>DataSource 는 JDBC 관련 Bean 이 주입되어야 합니다</li>
  <li>JDBC 관련 Bean 은 JPA Repository Bean 이 주입 되어야 합니다</li>
  <li>JPA Repository Bean 은 DataSource Bean 이 주입되어야 합니다</li>
  <li>….</li>
</ol>

<p>그림에서는 RoutingDataSource 에 defaultTargetDataSource 와 targetDataSources 를 Resolve 하는 과정을 보여줍니다.</p>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/35-set_routing_sources.svg" alt="35-set_routing_sources" /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@RequiredArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DataSourceConfig</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">DataSourceWrapper</span> <span class="n">defaultDataSource</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RoutingDataSource</span> <span class="n">routingDataSource</span> <span class="o">=</span> <span class="nc">RoutingDataSource</span><span class="o">.</span><span class="na">of</span><span class="o">();</span>

  <span class="c1">// RoutingDataSource 를 DataSource Bean 으로 등록합니다</span>
  <span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="nc">DataSource</span> <span class="nf">dataSource</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 초기에 Bean 으로 등록할 때, Admin DataSource 만 ResolvedDefaultDataSource 로 저장합니다.</span>
    <span class="n">routingDataSource</span><span class="o">.</span><span class="na">setDefaultDataSource</span><span class="o">(</span><span class="n">defaultDataSource</span><span class="o">.</span><span class="na">getDataSource</span><span class="o">());</span>
    <span class="k">return</span> <span class="n">routingDataSource</span><span class="o">;</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RoutingDataSource</span> <span class="kd">extends</span> <span class="nc">AbstractRoutingDataSource</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">HikariDataSource</span> <span class="n">defaultTargetDS</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDefaultDataSource</span><span class="o">(</span><span class="nc">HikariDataSource</span> <span class="n">dataSource</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">defaultTargetDS</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">;</span>
        <span class="n">resolve</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDataSources</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">InfoOfDBConnections</span><span class="o">&gt;</span> <span class="n">infoOfDBConnections</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">targetDS</span> <span class="o">=</span> <span class="nc">DataSources</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">infoOfDBConnections</span><span class="o">).</span><span class="na">get</span><span class="o">();</span>
        <span class="n">resolve</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">resolve</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">setDefaultTargetDataSource</span><span class="o">(</span><span class="n">defaultTargetDS</span><span class="o">);</span>
        <span class="n">setTargetDataSources</span><span class="o">(</span><span class="n">targetDS</span><span class="o">);</span>
        <span class="n">afterPropertiesSet</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">resolve()</code> 메서드는 다음과 같은 일을 합니다.</p>
<ul>
  <li>setDefaultTargetDataSource(defaultTargetDS)
    <ul>
      <li>AbstractRoutingDataSource 의 defaultTargetDataSource 멤버 변수의 값에 저장합니다.</li>
    </ul>
  </li>
  <li>setTargetDataSources(targetDS)
    <ul>
      <li>AbstractRoutingDataSource 의 targetDataSources 멤버 변수의 값을 저장합니다.</li>
    </ul>
  </li>
  <li>afterPropertiesSet()
    <ul>
      <li>AbstractRoutingDataSource
        <ul>
          <li>defaultTargetDataSource 을 <code class="language-plaintext highlighter-rouge">resolvedDefaultDataSource</code> 에 복사합니다.</li>
          <li>targetDataSources 를 <code class="language-plaintext highlighter-rouge">resolvedDataSources</code> 에 복사합니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">DataSources</code> 클래스는 
List<InfoOfDBConnections> 객체를 Map&lt;String, HikariDataSource&gt; 타입으로 변환하여 래핑합니다.</InfoOfDBConnections></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@NoArgsConstructor</span><span class="o">(</span><span class="n">access</span> <span class="o">=</span> <span class="nc">AccessLevel</span><span class="o">.</span><span class="na">PRIVATE</span><span class="o">)</span>
<span class="nd">@AllArgsConstructor</span><span class="o">(</span><span class="n">access</span> <span class="o">=</span> <span class="nc">AccessLevel</span><span class="o">.</span><span class="na">PRIVATE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DataSources</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">HikariDataSource</span><span class="o">&gt;</span> <span class="n">dataSources</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">HikariDataSource</span><span class="o">&gt;</span> <span class="n">dataSources</span><span class="o">,</span> <span class="nc">DataSourceWrapper</span> <span class="n">dataSourceWrapper</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">dataSources</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">dataSourceWrapper</span><span class="o">.</span><span class="na">getServiceKey</span><span class="o">(),</span> <span class="n">dataSourceWrapper</span><span class="o">.</span><span class="na">getDataSource</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="nc">DataSources</span> <span class="nf">of</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">InfoOfDBConnections</span><span class="o">&gt;</span> <span class="n">infoOfDBConnections</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">HikariDataSource</span><span class="o">&gt;</span> <span class="n">dataSources</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="n">infoOfDBConnections</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                       <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">info</span> <span class="o">-&gt;</span> <span class="n">info</span><span class="o">.</span><span class="na">getIsSuccess</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>    <span class="c1">// 연결 가능한 Database 만을 필터</span>
                       <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">info</span> <span class="o">-&gt;</span> <span class="n">put</span><span class="o">(</span><span class="n">dataSources</span><span class="o">,</span> <span class="nc">DataSourceWrapper</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">info</span><span class="o">)));</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nf">DataSources</span><span class="o">(</span><span class="n">dataSources</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// DataSources 를 실제 DataSource 의 TargetDataSources 에 저장할 때, Map&lt;Object, Object&gt; 타입으로 변환이 되어야 합니다.</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;(</span><span class="n">dataSources</span><span class="o">);</span> 
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="5-서비스-별-datasource-등록하기">(5) 서비스 별 DataSource 등록하기</h3>
<p>앞서, Bean 초기화 단계에서 JPA Repository 의 의존성을 사용할 수 없다는 것을 확인했습니다.</p>

<p>문제를 해결하기 위해, 스프링 부트 Application 실행 후 서비스 별 DataSources 를 등록해야 했고, <br />
<code class="language-plaintext highlighter-rouge">ApplicationRunner</code> 를 구현해 <code class="language-plaintext highlighter-rouge">run</code> 메서드를 오버라이드 하는 방법을 사용했습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootApplication</span><span class="o">(</span><span class="n">exclude</span> <span class="o">=</span> <span class="o">{</span><span class="nc">DataSourceAutoConfiguration</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="nd">@EnableConfigurationProperties</span><span class="o">({</span> <span class="nc">DefaultDBProperty</span><span class="o">.</span><span class="na">class</span> <span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">QuartzVueAdminApplication</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// ...</span>
  <span class="o">}</span>

  <span class="nd">@Component</span>
  <span class="nd">@RequiredArgsConstructor</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">RunAfterApplicationStart</span> <span class="kd">implements</span> <span class="nc">ApplicationRunner</span> <span class="o">{</span>

    <span class="nd">@UpdateDataSource</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="nc">ApplicationArguments</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span> <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>run 의 본문은 비어있지만, <code class="language-plaintext highlighter-rouge">@UpdateDataSource</code> 라는 커스텀 Aspect 어노테이션을 사용했습니다. <br />
이 어노테이션은 DataSource 를 INFO_OF_DB_CONNECTIONS 테이블의 데이터와 동기화 하는 기능을 합니다.<br />
앱 실행 시 외에도, INFO_OF_DB_CONNECTIONS 데이터 변경이 될 때에도 사용되는 로직이기 때문에 annotation 으로 구현해 보았습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequiredArgsConstructor</span>
<span class="nd">@Component</span>
<span class="nd">@Aspect</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UpdateDataSourceAspect</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RoutingDataSource</span> <span class="n">routingDataSource</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">InfoOfDBConnectionService</span> <span class="n">infoOfDBConnectionService</span><span class="o">;</span>

  <span class="nd">@Around</span><span class="o">(</span><span class="s">"@annotation(UpdateDataSource)"</span><span class="o">)</span>
  <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">update</span><span class="o">(</span><span class="nc">ProceedingJoinPoint</span> <span class="n">joinPoint</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
    <span class="nc">Object</span> <span class="n">res</span> <span class="o">=</span> <span class="n">joinPoint</span><span class="o">.</span><span class="na">proceed</span><span class="o">();</span>

    <span class="n">routingDataSource</span><span class="o">.</span><span class="na">setDataSources</span><span class="o">(</span><span class="n">infoOfDBConnectionService</span><span class="o">.</span><span class="na">findAllUpdatedIsSuccess</span><span class="o">());</span>

    <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/40-ds_update.svg" alt="40-ds_update" /></p>

<p>먼저 UpdateDataSourceAspect 에서, infoOfDBConnectionService.findAllUpdatedIsSuccess() 를 호출 합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InfoOfDBConnectionService</span> <span class="o">{</span>
  <span class="c1">// ...</span>

  <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">InfoOfDBConnections</span><span class="o">&gt;</span> <span class="nf">findAllUpdatedIsSuccess</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">infoOfDBConnectionRepository</span><span class="o">.</span><span class="na">findAll</span><span class="o">()</span>
                                       <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                                       <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">info</span> <span class="o">-&gt;</span> <span class="o">{</span>
                                         <span class="kt">byte</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                                         <span class="k">try</span> <span class="o">{</span>
                                           <span class="n">result</span> <span class="o">=</span> <span class="nc">DBConnection</span><span class="o">.</span><span class="na">create</span><span class="o">().</span><span class="na">test</span><span class="o">(</span><span class="n">info</span><span class="o">);</span>
                                         <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">SQLException</span> <span class="n">ignored</span><span class="o">)</span> <span class="o">{}</span>
                                         <span class="n">info</span><span class="o">.</span><span class="na">setIsSuccess</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
                                         <span class="k">return</span> <span class="n">infoOfDBConnectionRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">info</span><span class="o">);</span>
                                       <span class="o">}).</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>findAllUpdatedIsSuccess() 에서는, DataBase 의 연결가능 여부를 확인하고, 각 레코드의 IsSuccess 필드를 업데이트한 결과를 반환합니다.</p>

<p>DataBase 의 연결 가능여부를 확인할 때에는 <code class="language-plaintext highlighter-rouge">DBConnection.create().test(InfoOfDBConnection)</code> 을 사용합니다.
이 때, 직접 DriverManager.getConnection 을 사용하고, 어떤 에러가 발생하거나, 1초 내에 커넥션을 할 수 없을 경우, 
연결할 수 없음을 나타내는 0 을 반환하게 됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@NoArgsConstructor</span><span class="o">(</span><span class="n">access</span> <span class="o">=</span> <span class="nc">AccessLevel</span><span class="o">.</span><span class="na">PRIVATE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DBConnection</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">DEFAULT_DRIVER_CLASS_NAME</span> <span class="o">=</span> <span class="s">"com.mysql.cj.jdbc.Driver"</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">CONNECTION_TIMEOUT</span> <span class="o">=</span> <span class="s">"&amp;connectTimeout=1000"</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="nc">DBConnection</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">DBConnection</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">byte</span> <span class="nf">test</span><span class="o">(</span><span class="nc">InfoOfDBConnections</span> <span class="n">infoOfDBConnection</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">SQLException</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">infoOfDBConnection</span><span class="o">.</span><span class="na">setDriverClassName</span><span class="o">(</span><span class="no">DEFAULT_DRIVER_CLASS_NAME</span><span class="o">);</span>

      <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">infoOfDBConnection</span><span class="o">.</span><span class="na">getDriverClassName</span><span class="o">());</span>
      <span class="n">conn</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span>
          <span class="n">infoOfDBConnection</span><span class="o">.</span><span class="na">getUrl</span><span class="o">()</span> <span class="o">+</span> <span class="no">CONNECTION_TIMEOUT</span><span class="o">,</span>
          <span class="n">infoOfDBConnection</span><span class="o">.</span><span class="na">getUsername</span><span class="o">(),</span>
          <span class="n">infoOfDBConnection</span><span class="o">.</span><span class="na">getPassword</span><span class="o">()</span>
      <span class="o">);</span>

      <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
      <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
      <span class="n">close</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">SQLException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">conn</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="k">this</span><span class="o">.</span><span class="na">conn</span><span class="o">.</span><span class="na">isClosed</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">conn</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>마지막으로 routingDataSource.setDataSources(List<InfoOfDBConnections> infoOfDBConnections) 을 호출하면, 
DataSource 가 INFO_OF_DB_CONNECTIONS 테이블과 동기화 됩니다.</InfoOfDBConnections></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@NoArgsConstructor</span><span class="o">(</span><span class="n">access</span> <span class="o">=</span> <span class="nc">AccessLevel</span><span class="o">.</span><span class="na">PRIVATE</span><span class="o">)</span>
<span class="nd">@AllArgsConstructor</span><span class="o">(</span><span class="n">access</span> <span class="o">=</span> <span class="nc">AccessLevel</span><span class="o">.</span><span class="na">PRIVATE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RoutingDataSource</span> <span class="kd">extends</span> <span class="nc">AbstractRoutingDataSource</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">targetDS</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="nc">HikariDataSource</span> <span class="n">defaultTargetDS</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDataSources</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">InfoOfDBConnections</span><span class="o">&gt;</span> <span class="n">infoOfDBConnections</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">targetDS</span> <span class="o">=</span> <span class="nc">DataSources</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">infoOfDBConnections</span><span class="o">).</span><span class="na">get</span><span class="o">();</span>
        <span class="n">resolve</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">resolve</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">setDefaultTargetDataSource</span><span class="o">(</span><span class="n">defaultTargetDS</span><span class="o">);</span>
        <span class="n">setTargetDataSources</span><span class="o">(</span><span class="n">targetDS</span><span class="o">);</span>
        <span class="n">afterPropertiesSet</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="6-사용할-datasource-선택하기">(6) 사용할 DataSource 선택하기</h3>
<p>메뉴에서 서비스를 선택할 때마다, Path Variable 이 변경이 됩니다.</p>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/36-menu_service.PNG" alt="36-menu_service" />
<img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/37-ds_path_var.PNG" alt="37-ds_path_var" /></p>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/38-use_ds.svg" alt="38-use_ds" /></p>

<p>우선 Axios Interceptor 에서는 path variables 에 따라서 http request 에 service-key 헤더 값을 저장합니다.
그럼 매 요청마다 params 의 db 값을 보고, service-key 헤더값이 달라집니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">axios</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">axios</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">router</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@/router</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">setup</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">axios</span><span class="p">.</span><span class="nx">interceptors</span><span class="p">.</span><span class="nx">request</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span>
    <span class="nx">config</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">config</span><span class="p">.</span><span class="nx">headers</span><span class="p">[</span><span class="dl">'</span><span class="s1">service-key</span><span class="dl">'</span><span class="p">]</span> <span class="o">=</span> <span class="nx">router</span><span class="p">?.</span><span class="nx">history</span><span class="p">?.</span><span class="nx">current</span><span class="p">?.</span><span class="nx">params</span><span class="p">?.</span><span class="nx">db</span>
        <span class="p">??</span> <span class="kc">null</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">config</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="nx">error</span> <span class="o">=&gt;</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
  <span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>스프링 부트에서는 WebMvcConfigurer 를 구현한 WebMvcConfig 클래스에서, <code class="language-plaintext highlighter-rouge">addInterceptors(InterceptorRegistry registry)</code> 를 오버라이드 합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequiredArgsConstructor</span>
<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WebMvcConfig</span> <span class="kd">implements</span> <span class="nc">WebMvcConfigurer</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">DataSourceControllerInterceptor</span> <span class="n">dataSourceControllerInterceptor</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">WILD</span> <span class="o">=</span> <span class="s">"/**"</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">notLoadList</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span>
      <span class="s">"/api/managements"</span> <span class="o">+</span> <span class="no">WILD</span>
  <span class="o">);</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addInterceptors</span><span class="o">(</span><span class="nc">InterceptorRegistry</span> <span class="n">registry</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// DataSourceControllerInterceptor 인터셉터 추가</span>
    <span class="n">registry</span><span class="o">.</span><span class="na">addInterceptor</span><span class="o">(</span><span class="n">dataSourceControllerInterceptor</span><span class="o">)</span>  
            <span class="c1">// "/api" 로 시작하는 모든 path 에서 DataSourceControllerInterceptor 를 거치도록 합니다.</span>
            <span class="o">.</span><span class="na">addPathPatterns</span><span class="o">(</span><span class="s">"/api"</span> <span class="o">+</span> <span class="no">WILD</span><span class="o">)</span>                   
            <span class="c1">// "/api/managements" 로 시작하는 모든 path 에서 DataSourceControllerInterceptor 를 제외합니다. </span>
            <span class="o">.</span><span class="na">excludePathPatterns</span><span class="o">(</span><span class="n">notLoadList</span><span class="o">)</span>                 
    <span class="o">;</span> 
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>DataSourceControllerInterceptor 는 다음과 같습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequiredArgsConstructor</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DataSourceControllerInterceptor</span> <span class="kd">extends</span> <span class="nc">HandlerInterceptorAdapter</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RoutingDataSource</span> <span class="n">dataSource</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">preHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span>
      <span class="nc">Object</span> <span class="n">handler</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

    <span class="nc">String</span> <span class="no">DATA_SOURCE_TYPE_HEADER_NAME</span> <span class="o">=</span> <span class="s">"service-key"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">serviceKeyOfHeader</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="no">DATA_SOURCE_TYPE_HEADER_NAME</span><span class="o">);</span>
    <span class="n">dataSource</span><span class="o">.</span><span class="na">validateTargetKey</span><span class="o">(</span><span class="n">serviceKeyOfHeader</span><span class="o">);</span>

    <span class="nc">DataSourceLookupKeyContextHolder</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">serviceKeyOfHeader</span><span class="o">);</span>

    <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">preHandle</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="n">handler</span><span class="o">);</span>

  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">,</span>
      <span class="nc">ModelAndView</span> <span class="n">modelAndView</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">DataSourceLookupKeyContextHolder</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">postHandle</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">,</span> <span class="n">handler</span><span class="o">,</span> <span class="n">modelAndView</span><span class="o">);</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>request header 에서 service-key 의 값을 가져와 유효성을 검사합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">serviceKeyOfHeader</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="no">DATA_SOURCE_TYPE_HEADER_NAME</span><span class="o">);</span>
<span class="n">dataSource</span><span class="o">.</span><span class="na">validateTargetKey</span><span class="o">(</span><span class="n">serviceKeyOfHeader</span><span class="o">);</span>
</code></pre></div></div>

<p>RoutingDataSource 의 targetDS 에서 service-key 가 발견되지 않으면 에러를 던집니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RoutingDataSource</span> <span class="kd">extends</span> <span class="nc">AbstractRoutingDataSource</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">targetDS</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">validateTargetKey</span><span class="o">(</span><span class="nc">String</span> <span class="n">serviceKey</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">targetDS</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">serviceKey</span><span class="o">))</span>
                <span class="o">.</span><span class="na">orElseThrow</span><span class="o">(</span><span class="nl">InvalidServiceKeyOfHttpRequestHeaderException:</span><span class="o">:</span><span class="k">new</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>lookupKey 의 값을 바꿔줍니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DataSourceLookupKeyContextHolder</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">serviceKeyOfHeader</span><span class="o">);</span>
</code></pre></div></div>

<p>컨트롤러 메서드가 종료되면 DataSourceControllerInterceptor 의 postHandle 메서드가 호출됩니다.
여기서는 ThreadLocal 변수 DATA_SOURCE_KEY 를 remove 해줍니다. 
쓰레드가 종료될 때, 특히 웹 애플리케이션의 경우 쓰레드 pool 로 공유되기 때문에 기존 데이터의 clear 가 필요합니다.</p>

<h3 id="동적으로-datasource-변경하기">동적으로 DataSource 변경하기</h3>
<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/05-dbconfig_main.jpg" alt="05-dbconfig_main" /></p>

<p><strong>DB Config</strong> 메뉴에서는 DatSource 의 추가, 삭제, 변경이 가능합니다.</p>

<p><img src="/images/portal/post/2021-01-25-ZUM-Pilot-advanced_quartz_scheduler_admin/39-ds_aspect.svg" alt="39-ds_aspect" /></p>

<p>InfoOfDBConnectionService 의 findAll, save, deleteById, updatePassword, updateExcludePassword 를 하고나면 <code class="language-plaintext highlighter-rouge">UpdateDataSourceAspect</code> 의 update 메서드를 실행합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ...</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InfoOfDBConnectionService</span> <span class="o">{</span>

  <span class="nd">@UpdateDataSource</span>
  <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">InfoOfDBConnectionDTO</span><span class="o">&gt;</span> <span class="nf">findAll</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// ...</span>
  <span class="o">}</span>
  
  <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>UpdateDataSourceAspect 이후 과정은 최초 DataSources 초기화 방식과 같습니다.</p>

<h2 id="후기">후기</h2>
<p>입사하자마자 한 서비스의 온전한 담당자가 된다는 것은 두렵기도 하지만 저에겐 신입으로서 누릴 수 있는 최고의 영광이라고 생각합니다.  <br />
기술적으로는 백엔드 역량이 부족한 저에게, 데이터소스를 다루는 미션을 주셨습니다. 데이터 소스를 구축하는 작업에만 3 주의 시간이 걸렸습니다.   <br />
블로그를 정리할 즈음에야 내가 사용하는 것들의 잘못된 이해도 깨닫고, 꿈에서도 생각을 하며. 많은 리팩터링 작업의 연속이 되었습니다.<br />
특히, 단순히 API 만 만들어 본 저에게는 백엔드의 맛을 톡톡히 보여주었습니다.  <br />
아직도 이해하지 못한 것들에 대한 무궁무진한 궁금증이 생겨났고, 이것이 백엔드의 매력이구나! 를 느끼게 되었습니다.
그리고 앞으로 담당하게 될 서비스에 대한 OJT 를 들었는데요. Quartz Scheduler Admin 에 대해 몰랐었더라면, 이해하지 못했을 것 같습니다!  <br />
마지막으로 Quartz Scheduler Admin 이라는 미션을 주셔서 정말 감사드리고, 
기술블로그를 쓰면서 마지막 까지 용기를 잃지 않게 응원해 주신 분들께 감사드립니다!</p>

:ET